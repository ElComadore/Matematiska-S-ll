% Skrivet av Nils

Algoritmerna i \cite{HaraldSieve} presenteras i form av pseudokod som för att kunna användas, måste översättas till något programmeringsspråk, här valdes Python.
Det var möjligt att översätta pseudokoden mer eller mindre ordagrant, vilket gjordes och resulterade i en första version av programmet.
Därefter kunde flera förbättringar av koden göras för att korta ned dess körningstid. 
Vissa av förbättringarna var möjliga då pseudokoden i \cite{HaraldSieve} är skriven i syfte att tydligt illustrera algoritmerna,
och är således inte ämnad till att vara färdig, optimerad kod.
Andra förbättringar var språkspecifika och åstadkoms genom att jämföra beräkningstiden hos olika funktioner och metoder i Python, för att sedan implementera de som visade sig vara snabba. 
Den förbättrade versionen av koden finns bifogad i appendix.
Nedan följer, utan inbördes ordning, några av de gjorda förbättringar som har haft större inverkan.
\begin{myitemize}
    \item
    Istället för att spara och göra beräkningar på en vektor av booleaner, väljer vi att uttrycka mängden som en bitsträng. 
    Denna idé föreslås redan i \cite{HaraldSieve} och sparar i första hand minne,
    som i sin tur kan leda till snabbare beräkningar på grund av bättre användning av cache.
    Här användes Python-biblioteket \textit{Bitarray}.
    \item
    På vissa ställen har det varit möjligt att flytta ut beräkningar utanför loopar så att samma beräkning inte behöver göras flera gånger. Flera beräkningar har även kunnat förkortas eller skrivas ihop för att undvika temporära variabler.
    \item
    I Python kan operatorn \texttt{x//y} användas för division utan rest, denna visar sig vara snabbare än sammansättningen \texttt{floor(x/y)}, detta ger också att \texttt{ceil(x/y)} kan bytas ut mot \texttt{-(x//-y)}.
\end{myitemize}
En ytterligare förbättring kunde göras efter en noggrann analys av pseudokoden för \textsc{NewSegSiev} i \cite[s.338]{HaraldSieve}.
Efter en approximering erhålls $n'\geq0$, en multipel av $m>0$ som möjligen uppfyller $n'\in[n-\Delta,n+\Delta]$ och $n'>m$.
Enligt \cite{HaraldSieve} ska dessa tre villkor testas en efter en,
men i själva verket är $n'\leq n+\Delta$ alltid uppfyllt eftersom $n'$ definieras som
\begin{equation} \label{helf.nprim}
    n' := \left\lfloor \frac{n+\Delta}{m} \right\rfloor\cdot m,
\end{equation}
vilken givetvis är mindre eller lika med $\frac{n+\Delta}{m}\cdot m = n+\Delta$. 
Vidare inspekterar vi villkoret $n'>m$, där (\ref{helf.nprim}) ger oss att 
\begin{equation*}
    n'>m \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor > 1 \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor \geq 2 \iff
    (n+\Delta)/2\geq m.
\end{equation*}
Men $m$ väljs ur intervallet $[M,M+2R]$ så det räcker med att undersöka ifall $M+2R\leq(n+\Delta)/2$. 
Det gäller att $M\leq\sqrt{n+\Delta}$ och $R:=\lfloor M\sqrt{\Delta/4n}\rfloor$,
således håller 
\begin{equation*}
    M+2R \leq
    \sqrt{n+\Delta}\left(1+ \sqrt{\Delta/n}\right) \leq 2\sqrt{n+\Delta}
\end{equation*}
eftersom $1\leq\Delta\leq n$. Vilket i sin tur ger oss att
\begin{equation*}
    m \leq 2\sqrt{n+\Delta} \leq (n+\Delta)/2,
\end{equation*}
där den sista olikheten håller så länge $n+\Delta\geq16$. 
Att sålla efter primtal i en lista av positiva heltal mindre än $16$ är ointressant.
Därför kan vi rimligtvis introducera kravet $n+\Delta\geq16$ i början av \textsc{NewSegSiev},
så att $n'>m$ alltid håller och inte behöver testas senare i algoritmen.
Det har följaktligen visat sig att utav de tre villkor som skulle testas, 
så är två av dem alltid uppfyllda och behöver därmed inte prövas.
Det totala antalet gånger som detta steg utförs är
\begin{equation*}
    O\left(\Delta\log n + \sqrt{\Delta/n}(\log n)^2\right),
\end{equation*}
enligt \cite[s.346]{HaraldSieve} och vi sparar således en betydande mängd tid på att reducera antalet beräkningar här till en tredjedel av det ursprungliga.

För att visa att de förändringar som gjorts i koden, faktiskt har haft inverkan så lät vi utföra tester.
Testerna gjordes på en hemdator och jämförde körningstid mellan den första versionen av programmet, mot en senare version där förbättringarna har införts.
Som tidigare nämnts så sållar programmet fram primtal i ett angivet intervall $[n-\Delta,n+\Delta]$ och 
programmets tillvägagånssätt varierar något beroende på förhållandet mellan $\Delta$ och $n$.
Av denna anledning utfördes två stycken tester där detta förhållande sattes till att vara så stort som möjligt respektive så litet som möjligt.
I det första testet valdes således $\Delta:=n$ och tre mätningar utfördes för $n=5\cdot10^3,5\cdot10^5,5\cdot10^7$.
I det andra testet valdes $\Delta:=\sqrt[3]{n}$ och $n$ fick anta värdena $10^9$, $10^{12}$ respektive $10^{15}$.
För alla mätningar visade sig den förbättrade versionen vara minst 10 gånger så snabb som den ursprungliga versionen, dessutom visar mätningarna på en antydan till att denna faktor ökar då $n$ växer. De uppmätta tiderna finnes i tabell \ref{implementering.tidtabell}.

\begin{table}[H]
\centering
\input{nils/tidtabell}
\caption{
Uppmätta körningstider för den första versionen, respektive den förbättrade versionen av programmet.
Programmet sållade fram alla primtal i ett intervall på formen $[n-\Delta,n+\Delta]$ där $\Delta=n$ för de tre första mätningarna och $\Delta=\sqrt[3]{n}$ för de tre sista.
Den förbättrade versionen var snabbare än den första versionen med en faktor på minst 10, för alla mätningar.}
\label{implementering.tidtabell}
\end{table}


Givetvis är programmet inte perfekt och det finns flera knep som kan utforskas ifall ytterligare förbättring av koden eftertraktas.
I den ursprungliga artikeln \cite{HaraldSieve} nämns ett fåtal eventuella förbättringar, här ges ytterligare två stycken.
\begin{myitemize}
    \item
    Istället för att flera gånger om låta \textsc{SimpleSiev(M)} generera en lista med alla primtal upp till $M$ kan det eventuellt spara tid att generera en godtycklig lista vid start av programmet.
    Värdet på $M$ överskrider inte $\sqrt{K\Delta+\sqrt{K\Delta}}$, vilket gör denna taktik rimlig.
    Exempelvis tar en lista med alla primtal upp till en miljard omkring 1GB att spara och kan användas för $n\leq 10^{35}$, så länge som vi håller oss till något mindre interval där $\Delta\leq\sqrt{n}$.
    Detta handlar självklart om en avvägning mellan hur snabbt det går att läsa in sparad data mot hur snabbt det går att beräkna den från grunden och bör undersökas mer innan idén tillämpas.
    \item
    Flera beräkningar kan utföras parallellt, vilket redan föreslås i \cite{HaraldSieve}. 
    I synnerhet kan detta nyttjas i andra delen av \textsc{NewSegSiev} där oberoende beräkningar utförs för varje $j\in[-k-1,k+1]$.
    Dessa beräkningar är alla enkla och på samma form, och det kan således vara gynnsamt att överlåta dessa till datorns GPU.
\end{myitemize}

I nästkommande stycke presenteras diverse resultat som erhållits ifrån körning av programmet.

\begin{comment}
    \item
    Deklaration av temporära variabler har i vissa fall kunnat uteslutas genom sammanskrivning av flera uttryck. 
    Ett specialfall av detta nyttjas i \textsc{DiophAppr} där vi har ersatt uttryck på formen \texttt{temp=x; x=y; y=temp;} med det snabbare \texttt{x,y=y,x;}.

    \item Flera while-loopar har kunnat ersättas med for-loopar,
    som ger att istället för att testa ett argument för varje iteration i loopen,
    behöver argumentet bara testas en gång när loopen påbörjas.
    \item Infogande av iteratorer vid iterering över primtalslistor, vilket också resulterar i bättre nyttjande av cache.

    \item
    I \textsc{DiophAppr} beräknas både heltals- och decimaldelen av $\alpha$. Detta görs i nuläget separat men skulle kunna göras samtidigt.
    Förslagsvis skulle då if-satsen ändras till att testa ifall decimaldelen är noll.
\end{comment}