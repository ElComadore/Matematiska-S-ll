% Skrivet av Nils

Algoritmerna i \cite{HaraldSieve} presenteras i form av pseudokod som för att kunna användas, måste översättas till något programmeringsspråk, här valdes Python.
Det var möjligt att översätta pseudokoden mer eller mindre ordagrant, vilket gjordes och resulterade i en första version av programmet.
Därefter kunde flera förbättringar av koden göras för att korta ned dess körningstid. 
Vissa av förbättringar var möjliga då pseudokoden i \cite{HaraldSieve} är skriven i syfte att tydligt illustrera algoritmerna,
och är således inte ämnad till att vara färdig, optimerad kod.
Andra förbättringar var språkspecifika och åstadkoms genom att jämföra beräkningstiden hos olika funktioner och metoder i Python, för att sedan implementera de som visade sig vara snabba. Nedan följer, utan inbördes ordning, några av de förbättringar som gjorts
\begin{myitemize}
    \item Istället för att spara och göra beräkningar på en vektor av booleaner, väljer vi att uttrycka mängden som en bitsträng. 
    Denna idé föreslås redan i \cite{HaraldSieve} och sparar i första hand minne,
    som i sin tur kan leda till snabbare beräkningar på grund av bättre användning av cache.
    Här användes Python-biblioteket \textit{Bitarray}.
    \item På vissa ställen har det varit möjligt att flytta ut beräkningar utanför loopar så att samma beräkning inte behöver göras flera gånger.
    \item Flera while-loopar har kunnat ersättas med for-loopar,
    som ger att istället för att testa ett argument för varje iteration i loopen,
    behöver argumentet bara testas en gång när loopen påbörjas.
    \item Infogande av iteratorer vid iterering över primtalslistor, vilket också har resulterat i bättre nyttjande av cache.
    \item I Python kan operatorn \texttt{x//y} användas för division utan rest, denna visar sig vara snabbare än sammansättningen \texttt{floor(x/y)},
    detta ger också att \texttt{ceil(x/y)} kan bytas ut mot \texttt{-(x//-y)}. Operatorn \texttt{isqrt(x)} har fått ersätta \texttt{floor(sqrt(x))} på liknande sätt.
    \item Deklaration av temporära variabler har i vissa fall kunnat uteslutas genom sammanskrivning av flera uttryck. 
    Ett specialfall av detta nyttjas i \textsc{DiophAppr} där vi har ersatt uttryck på formen \texttt{temp=x; x=y; y=temp;} med det snabbare \texttt{x,y=y,x;}.
\end{myitemize}
En ytterligare förbättring kunde göras efter en noggrann analys av pseudokoden för \textsc{NewSegSiev} i \cite[s.338]{HaraldSieve}.
Efter en approximering erhålls $n'\geq0$, en multipel av $m>0$ som möjligen uppfyller $n'\in[n-\Delta,n+\Delta]$ och $n'>m$.
Enligt \cite{HaraldSieve} ska dessa tre villkor testas en efter en,
men i själva verket är $n'\leq n+\Delta$ alltid uppfyllt eftersom $n'$ definieras som
\begin{equation} \label{helf.nprim}
    n' := \left\lfloor \frac{n+\Delta}{m} \right\rfloor\cdot m,
\end{equation}
vilken givetvis är mindre eller lika med $\frac{n+\Delta}{m}\cdot m = n+\Delta$. 
Vidare inspekterar vi villkoret $n'>m$, (\ref{helf.nprim}) ger oss att 
\begin{equation*}
    n'>m \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor > 1 \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor \geq 2 \iff
    (n+\Delta)/2\geq m.
\end{equation*}
Men $m$ väljs ur intervallet $[M,M+2R]$ där $M\leq\sqrt{n+\Delta}$ och $R:=\lfloor M\sqrt{\Delta/4n}\rfloor$.
Således håller $M+2R\leq2\sqrt{n+\Delta}$ eftersom $1\leq\Delta\leq n$.
Detta medför att
\begin{equation*}
    m \leq M+2R \leq 2\sqrt{n+\Delta} \leq (n+\Delta)/2,
\end{equation*}
där den sista olikheten håller så länge $n+\Delta\geq16$. 
Att sålla efter primtal i en lista av positiva heltal mindre än $16$ är ointressant.
Därför kan vi rimligtvis introducera kravet $n+\Delta\geq16$ i början av \textsc{NewSegSiev},
så att $n'>m$ alltid håller och inte behöver testas senare i algoritmen.
Det har följaktligen visat sig att utav de tre villkor som ska testas, så är två av dem alltid uppfyllda och behöver därmed inte prövas.


\todo{Infoga graf där körningstid av gammal och ny kod jämförs}

\todo{Diskutera vilka ytterligare förbättringar som kan göras}