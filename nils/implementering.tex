% Skrivet av Nils

Algoritmerna i \cite{HaraldSieve} presenteras i form av pseudokod som för att kunna användas, måste översättas till något programmeringsspråk, här valdes Python.
Det var möjligt att översätta pseudokoden mer eller mindre ordagrant, vilket gjordes och resulterade i en första version av programmet.
Därefter kunde flera förbättringar av koden göras för att korta ned dess körningstid. 
Vissa av förbättringar var möjliga då pseudokoden i \cite{HaraldSieve} är skriven i syfte att tydligt illustrera algoritmerna,
och är således inte ämnad till att vara färdig, optimerad kod.
Andra förbättringar var språkspecifika och åstadkoms genom att jämföra beräkningstiden hos olika funktioner och metoder i Python, för att sedan implementera de som visade sig vara snabba. Nedan följer, utan inbördes ordning, några av de förbättringar som gjorts
\begin{myitemize}
    \item Istället för att spara och göra beräkningar på en vektor av booleaner, väljer vi att uttrycka mängden som en bitsträng. 
    Denna idé föreslås redan i \cite{HaraldSieve} och sparar i första hand minne,
    som i sin tur kan leda till snabbare beräkningar på grund av bättre användning av cache.
    Här användes Python-biblioteket \textit{Bitarray}.
    \item På vissa ställen har det varit möjligt att flytta ut beräkningar utanför loopar så att samma beräkning inte behöver göras flera gånger.
    \item Flera while-loopar har kunnat ersättas med for-loopar,
    som ger att istället för att testa ett argument för varje iteration i loopen,
    behöver argumentet bara testas en gång när loopen påbörjas.
    \item Infogande av iteratorer vid iterering över primtalslistor, vilket också resulterar i bättre nyttjande av cache.
    \item I Python kan operatorn \texttt{x//y} användas för division utan rest, denna visar sig vara snabbare än sammansättningen \texttt{floor(x/y)},
    detta ger också att \texttt{ceil(x/y)} kan bytas ut mot \texttt{-(x//-y)}. Operatorn \texttt{isqrt(x)} har fått ersätta \texttt{floor(sqrt(x))} på liknande sätt.
    \item Deklaration av temporära variabler har i vissa fall kunnat uteslutas genom sammanskrivning av flera uttryck. 
    Ett specialfall av detta nyttjas i \textsc{DiophAppr} där vi har ersatt uttryck på formen \texttt{temp=x; x=y; y=temp;} med det snabbare \texttt{x,y=y,x;}.
\end{myitemize}
En ytterligare förbättring kunde göras efter en noggrann analys av pseudokoden för \textsc{NewSegSiev} i \cite[s.338]{HaraldSieve}.
Efter en approximering erhålls $n'\geq0$, en multipel av $m>0$ som möjligen uppfyller $n'\in[n-\Delta,n+\Delta]$ och $n'>m$.
Enligt \cite{HaraldSieve} ska dessa tre villkor testas en efter en,
men i själva verket är $n'\leq n+\Delta$ alltid uppfyllt eftersom $n'$ definieras som
\begin{equation} \label{helf.nprim}
    n' := \left\lfloor \frac{n+\Delta}{m} \right\rfloor\cdot m,
\end{equation}
vilken givetvis är mindre eller lika med $\frac{n+\Delta}{m}\cdot m = n+\Delta$. 
Vidare inspekterar vi villkoret $n'>m$, där (\ref{helf.nprim}) ger oss att 
\begin{equation*}
    n'>m \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor > 1 \iff
    \left\lfloor \frac{n+\Delta}{m} \right\rfloor \geq 2 \iff
    (n+\Delta)/2\geq m.
\end{equation*}
Men $m$ väljs ur intervallet $[M,M+2R]$ så det räcker med att undersöka ifall $M+2R\leq(n+\Delta)/2$. 
Det gäller att $M\leq\sqrt{n+\Delta}$ och $R:=\lfloor M\sqrt{\Delta/4n}\rfloor$,
således håller 
\begin{equation*}
    M+2R \leq
    \sqrt{n+\Delta}\left(1+ \sqrt{\Delta/n}\right) \leq 2\sqrt{n+\Delta}
\end{equation*}
eftersom $1\leq\Delta\leq n$. Detta ger oss i sin tur att
\begin{equation*}
    m \leq 2\sqrt{n+\Delta} \leq (n+\Delta)/2,
\end{equation*}
där den sista olikheten håller så länge $n+\Delta\geq16$. 
Att sålla efter primtal i en lista av positiva heltal mindre än $16$ är ointressant.
Därför kan vi rimligtvis introducera kravet $n+\Delta\geq16$ i början av \textsc{NewSegSiev},
så att $n'>m$ alltid håller och inte behöver testas senare i algoritmen.
Det har följaktligen visat sig att utav de tre villkor som skulle testas, så är två av dem alltid uppfyllda och behöver därmed inte prövas.

\todo{Något om frekvensen av test för ovanstående villkor}

För att visa att ovanstående förändringar faktiskt snabbade upp programmet utfördes två stycken tester.
Testerna gjordes på en hemdator (Behövs mer spec?) och jämförde körningstid mellan den första versionen av programmet, mot en senare version där ovanstående förbättringar gjorts.
I båda testerna gjordes 100 stycken mätningar där värdet på $n$ gick över intervallet $[500000, 10^{15}]$ med konstant $K=2.5$.
Värdet på $\Delta$ valdes i det första testet som en funktion av $n$ med $\Delta := \lfloor2\sqrt[3]{n}\rfloor$,
detta i syfte att alla algoritmer i programmet skulle användas, vilket inträffar om $\Delta\in[\sqrt[3]{n},\sqrt{n}/K]$.
I det andra testet hölls värdet på $\Delta$ konstant för att testa olika förhållanden mellan $n$ och $\Delta$, här sattes $\Delta := 500000$ vilket ger en intervallbredd på en miljon. De uppmätta tiderna kan ses i figur (?). Den förbättrade versionen visade sig snabbare än den första med en faktor på 10 som minst och 27 som mest. Skillnaden var som störst då $n$ var nära den övre gränsen $10^{15}$ där det första testet gav tiderna $76.5$ och $2.8$ sekunder för den första respektive den förbättrade versionen.

\todo{Infoga graf där körningstid av gammal och ny kod jämförs}

Givetvis är programmet inte perfekt och det finns flera knep som kan utforskas för att förbättra koden.
I den ursprungliga artikeln \cite{HaraldSieve} nämns ett fåtal eventuella förbättringar, här ger vi ytterligare några.
\begin{myitemize}
    \item
    Istället för att flera gånger om låta \textsc{SimpleSiev(M)} generera en lista med alla primtal upp till $M$ kan det eventuellt spara tid att generera en godtycklig lista vid start av programmet.
    Värdet på $M$ överskrider inte $\sqrt{K\Delta+\sqrt{K\Delta}}$, vilket gör denna taktik rimlig.
    Exempelvis tar en lista med alla primtal upp till en miljard omkring 1GB att spara och kan ersätta \textsc{SimpleSiev} för $n\leq 10^{35}$, så länge som vi håller oss till mindre interval med $\Delta\leq\sqrt{n}$.
    Detta är självklart en avvägning mellan hur snabbt det går att läsa in sparad data mot hur snabbt det går att beräkna den från grunden och bör undersökas mer innan idén tillämpas.
    \item
    I \textsc{DiphAppr} beräknas heltals- och decimaldelen av $\alpha$ separat men skulle eventuellt kunna göras samtidigt.
    Förslagsvis skulle då if-satsen förändras till att testa ifall resten är noll.
    \item
    Flera beräkningar kan utföras parallellt, vilket redan föreslås i \cite{HaraldSieve}. 
    I synnerhet kan detta nyttjas i andra delen av \textsc{NewSegSiev} där oberoende beräkningar utförs för varje $j\in[-k-1,k+1]$.
    Dessa beräkningar är alla enkla och på samma form, och det kan således vara gynnsamt att överlåta dessa till datorns GPU (Källa kanske?).
\end{myitemize}

I nästkommande stycke presenteras resultat ifrån körning av programmet.
